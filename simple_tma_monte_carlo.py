#!/usr/bin/env python3
"""
Simplified TMA Overlay Strategy Monte Carlo Testing

This script runs a simplified Monte Carlo validation on the TMA Overlay strategy
using the synthetic data generator and bypassing the problematic dependencies.
"""

import os
import sys
import logging
import pandas as pd
import numpy as np
import random
from datetime import datetime

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Ensure the project root is in the path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = current_dir  # Assuming we're in the project root
sys.path.append(project_root)

# Import our simplified components
from simple_strategy_factory import SimpleStrategyFactory
from simple_data_loader import load_data

# Import the TMA strategy
from winning_strategies.tma_overlay_btc_strategy.tma_overlay_strategy import TMAOverlayStrategy

# Constants
MC_SIMULATIONS = 500
CONFIDENCE_LEVEL = 0.95
INITIAL_CAPITAL = 10000

def register_tma_strategy():
    """Register the TMA strategy with our strategy factory"""
    factory = SimpleStrategyFactory()
    factory.register_strategy("tma_overlay", TMAOverlayStrategy)
    return factory

def run_backtest(df, strategy):
    """
    Run a backtest using the strategy and data
    
    Args:
        df (pd.DataFrame): Price data with OHLCV
        strategy: Strategy instance
        
    Returns:
        list: List of trades generated by the strategy
    """
    # Calculate indicators
    df = strategy.populate_indicators(df)
    
    # Generate signals
    df = strategy.generate_signals(df)
    
    # Initialize account
    initial_balance = INITIAL_CAPITAL
    balance = initial_balance
    position = 0
    trades = []
    entry_price = 0
    entry_time = None
    
    # Run the backtest
    for i in range(1, len(df)):
        row = df.iloc[i]
        prev_row = df.iloc[i-1]
        
        # Check for buy signal
        if row['buy_signal'] == 1 and position <= 0:
            # Close any existing short position
            if position < 0:
                profit = entry_price - row['close']
                balance += profit
                trades.append({
                    'entry_time': entry_time,
                    'exit_time': row.name,
                    'entry_price': entry_price,
                    'exit_price': row['close'],
                    'profit': profit,
                    'type': 'short'
                })
            
            # Enter long position
            entry_price = row['close']
            entry_time = row.name
            position = 1
            
        # Check for sell signal
        elif row['sell_signal'] == 1 and position >= 0:
            # Close any existing long position
            if position > 0:
                profit = row['close'] - entry_price
                balance += profit
                trades.append({
                    'entry_time': entry_time,
                    'exit_time': row.name,
                    'entry_price': entry_price,
                    'exit_price': row['close'],
                    'profit': profit,
                    'type': 'long'
                })
            
            # Enter short position
            entry_price = row['close']
            entry_time = row.name
            position = -1
            
        # Check for exit signals
        elif ((position > 0 and row['exit_long'] == 1) or 
              (position < 0 and row['exit_short'] == 1)):
            
            if position > 0:
                profit = row['close'] - entry_price
                trade_type = 'long'
            else:
                profit = entry_price - row['close']
                trade_type = 'short'
                
            balance += profit
            trades.append({
                'entry_time': entry_time,
                'exit_time': row.name,
                'entry_price': entry_price,
                'exit_price': row['close'],
                'profit': profit,
                'type': trade_type
            })
            
            position = 0
    
    # Close any open position at the end
    if position != 0:
        row = df.iloc[-1]
        
        if position > 0:
            profit = row['close'] - entry_price
            trade_type = 'long'
        else:
            profit = entry_price - row['close']
            trade_type = 'short'
            
        balance += profit
        trades.append({
            'entry_time': entry_time,
            'exit_time': row.name,
            'entry_price': entry_price,
            'exit_price': row['close'],
            'profit': profit,
            'type': trade_type
        })
    
    # Calculate final balance and ROI
    final_balance = balance
    roi = (final_balance / initial_balance - 1) * 100
    
    # Log backtest results
    logger.info(f"Backtest completed with {len(trades)} trades")
    logger.info(f"Initial balance: ${initial_balance:.2f}, Final balance: ${final_balance:.2f}")
    logger.info(f"ROI: {roi:.2f}%")
    
    return trades

def run_monte_carlo_validation(trades, num_simulations=MC_SIMULATIONS, confidence_level=CONFIDENCE_LEVEL):
    """
    Run Monte Carlo simulation by randomizing trade order
    
    Args:
        trades (list): List of trade dictionaries
        num_simulations (int): Number of Monte Carlo simulations
        confidence_level (float): Confidence level for results
        
    Returns:
        dict: Monte Carlo simulation results
    """
    if not trades or len(trades) < 5:
        logger.error("Not enough trades for Monte Carlo simulation (minimum 5 required)")
        return None
    
    # Extract profits from trades
    trade_profits = [t.get('profit', 0) for t in trades]
    
    # Run simulations
    simulation_results = []
    all_equity_curves = []
    
    for _ in range(num_simulations):
        # Randomly shuffle trade order
        shuffled_profits = random.sample(trade_profits, len(trade_profits))
        
        # Calculate equity curve
        equity_curve = [INITIAL_CAPITAL]  # Start with initial capital
        for profit in shuffled_profits:
            equity_curve.append(equity_curve[-1] + profit)
        
        # Store equity curve for visualization
        all_equity_curves.append(equity_curve)
        
        # Calculate metrics for this simulation
        final_equity = equity_curve[-1]
        max_equity = max(equity_curve)
        
        # Calculate max drawdown
        peak = equity_curve[0]
        max_drawdown = 0
        
        for value in equity_curve:
            if value > peak:
                peak = value
            drawdown = (peak - value) / peak if peak > 0 else 0
            max_drawdown = max(max_drawdown, drawdown)
        
        # Calculate return
        total_return = (final_equity / INITIAL_CAPITAL - 1) * 100
        
        # Calculate other metrics
        profitable_trades = sum(1 for p in shuffled_profits if p > 0)
        win_rate = profitable_trades / len(shuffled_profits) if shuffled_profits else 0
        
        simulation_results.append({
            'final_equity': final_equity,
            'total_return': total_return,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'equity_curve': equity_curve
        })
    
    # Compile results into DataFrame
    df_results = pd.DataFrame([
        {k: v for k, v in result.items() if k != 'equity_curve'} 
        for result in simulation_results
    ])
    
    # Calculate confidence intervals
    lower_idx = int((1 - confidence_level) / 2 * num_simulations)
    upper_idx = int((1 - (1 - confidence_level) / 2) * num_simulations)
    
    final_equity_sorted = sorted(df_results['final_equity'])
    max_drawdown_sorted = sorted(df_results['max_drawdown'])
    
    # Calculate mean equity curve
    all_curves_array = np.array(all_equity_curves)
    mean_equity_curve = np.mean(all_curves_array, axis=0).tolist()
    
    # Save results to text file instead of plotting
    os.makedirs('reports', exist_ok=True)
    output_path = f"reports/tma_monte_carlo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    
    with open(output_path, 'w') as f:
        f.write("=== TMA Overlay Strategy Monte Carlo Validation Results ===\n\n")
        f.write(f"Simulations: {num_simulations}\n")
        f.write(f"Confidence Level: {confidence_level*100:.1f}%\n")
        f.write(f"Number of Trades: {len(trades)}\n\n")
        
        f.write("=== Equity Statistics ===\n")
        f.write(f"Initial Capital: ${INITIAL_CAPITAL:.2f}\n")
        f.write(f"Mean Final Equity: ${np.mean(df_results['final_equity']):.2f}\n")
        f.write(f"Median Final Equity: ${np.median(df_results['final_equity']):.2f}\n")
        f.write(f"Lower Bound Equity ({(1-confidence_level)/2*100:.1f}%): ${final_equity_sorted[lower_idx]:.2f}\n")
        f.write(f"Upper Bound Equity ({(1-(1-confidence_level)/2)*100:.1f}%): ${final_equity_sorted[upper_idx]:.2f}\n\n")
        
        f.write("=== Risk Statistics ===\n")
        f.write(f"Mean Max Drawdown: {np.mean(df_results['max_drawdown'])*100:.2f}%\n")
        f.write(f"Worst-case Max Drawdown ({(1-(1-confidence_level)/2)*100:.1f}%): {max_drawdown_sorted[upper_idx]*100:.2f}%\n")
        f.write(f"Mean Win Rate: {np.mean(df_results['win_rate'])*100:.2f}%\n\n")
        
        # Calculate robustness ratio
        robustness_ratio = final_equity_sorted[lower_idx] / INITIAL_CAPITAL
        
        # Assess strategy robustness
        if robustness_ratio >= 1.0:
            robustness = "STRONG"
        elif robustness_ratio >= 0.9:
            robustness = "MODERATE"
        else:
            robustness = "WEAK"
            
        f.write("=== Robustness Assessment ===\n")
        f.write(f"Robustness Ratio: {robustness_ratio:.2f}\n")
        f.write(f"Robustness Assessment: {robustness}\n\n")
        
        if robustness == "STRONG":
            f.write("The TMA Overlay strategy shows strong statistical robustness across randomized trade sequences.\n")
            f.write("It consistently maintains profitability within the confidence interval.\n")
        elif robustness == "MODERATE":
            f.write("The TMA Overlay strategy shows moderate statistical robustness.\n")
            f.write("It maintains most of its capital in worst-case scenarios but may need further optimization.\n")
        else:
            f.write("The TMA Overlay strategy lacks statistical robustness and needs significant improvement.\n")
            f.write("Consider adjusting parameters or exploring different approaches.\n")
    
    logger.info(f"Monte Carlo validation complete. Results saved to {output_path}")
    
    return {
        'mean_final_equity': np.mean(df_results['final_equity']),
        'median_final_equity': np.median(df_results['final_equity']),
        'mean_max_drawdown': np.mean(df_results['max_drawdown']),
        'mean_win_rate': np.mean(df_results['win_rate']),
        'lower_bound_equity': final_equity_sorted[lower_idx],
        'upper_bound_equity': final_equity_sorted[upper_idx],
        'max_drawdown_worst_case': max_drawdown_sorted[upper_idx],
        'confidence_level': confidence_level,
        'robustness_ratio': robustness_ratio,
        'robustness_assessment': robustness,
        'report_path': output_path
    }

def main():
    """Run the simplified Monte Carlo validation on TMA strategy"""
    # Register TMA strategy with our factory
    factory = register_tma_strategy()
    
    # Create TMA strategy instance with default parameters
    strategy = factory.create_strategy("tma_overlay")
    
    # Load synthetic data
    df = load_data(symbol='BTC/USDT', timeframe='4h', start_date='2022-01-01')
    
    # Run backtest
    trades = run_backtest(df, strategy)
    
    if not trades or len(trades) < 5:
        logger.error("Not enough trades generated. Try adjusting strategy parameters.")
        return
    
    # Log trade statistics
    total_trades = len(trades)
    winning_trades = sum(1 for t in trades if t.get('profit', 0) > 0)
    win_rate = winning_trades / total_trades if total_trades > 0 else 0
    profit_sum = sum(t.get('profit', 0) for t in trades)
    
    logger.info(f"Generated {total_trades} trades with {winning_trades} winners")
    logger.info(f"Win Rate: {win_rate*100:.1f}%")
    logger.info(f"Net Profit: ${profit_sum:.2f}")
    
    # Run Monte Carlo validation
    mc_results = run_monte_carlo_validation(trades)
    
    if mc_results:
        logger.info(f"Monte Carlo simulation results:")
        logger.info(f"Mean Final Equity: ${mc_results['mean_final_equity']:.2f}")
        logger.info(f"Mean Max Drawdown: {mc_results['mean_max_drawdown']*100:.1f}%")
        logger.info(f"{CONFIDENCE_LEVEL*100}% Confidence Interval: [${mc_results['lower_bound_equity']:.2f}, ${mc_results['upper_bound_equity']:.2f}]")
        logger.info(f"Worst-case Max Drawdown ({CONFIDENCE_LEVEL*100}%): {mc_results['max_drawdown_worst_case']*100:.1f}%")
        logger.info(f"Robustness assessment: {mc_results['robustness_assessment']} (Ratio: {mc_results['robustness_ratio']:.2f})")

if __name__ == "__main__":
    main() 